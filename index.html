<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Tetris</title>
<style>
body {
  margin: 0;
  background: #111;
  color: white;
  font-family: sans-serif;
}
.screen {
  display: none;
  height: 100vh;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}
.active { display: flex; }
canvas {
  background: black;
  border: 2px solid #555;
}
button {
  padding: 12px 24px;
  font-size: 18px;
  margin: 10px;
  cursor: pointer;
}
.settings {
  align-items: flex-start;
  padding: 20px;
}
.back-btn {
  position: absolute;
  top: 10px;
  left: 10px;
}
</style>
</head>
<body>

<!-- 메인 -->
<div id="menu" class="screen active">
  <h1>테트리스</h1>
  <button onclick="startGame()">시작하기</button>
  <button onclick="openSettings()">설정</button>
</div>

<!-- 게임 -->
<div id="game" class="screen">
  <canvas id="tetris" width="240" height="400"></canvas>
</div>

<!-- 설정 -->
<div id="settings" class="screen settings">
  <button class="back-btn" onclick="backToMenu()">← 뒤로</button>
  <h2>키 설정</h2>
  <div>왼쪽 <button onclick="setKey('left')" id="leftKey"></button></div>
  <div>오른쪽 <button onclick="setKey('right')" id="rightKey"></button></div>
  <div>아래 <button onclick="setKey('down')" id="downKey"></button></div>
  <div>회전 <button onclick="setKey('rotate')" id="rotateKey"></button></div>
  <div>하드드롭 <button onclick="setKey('drop')" id="dropKey"></button></div>
</div>

<script>
/* ================= 화면 ================= */
const menu = document.getElementById('menu');
const gameScreen = document.getElementById('game');
const settingsScreen = document.getElementById('settings');
const show = s => [menu,gameScreen,settingsScreen].forEach(v=>v.classList.toggle('active',v===s));
const startGame = ()=>{ resetGame(); show(gameScreen); };
const openSettings = ()=>{ updateKeyUI(); show(settingsScreen); };
const backToMenu = ()=> show(menu);

/* ================= 키 설정 ================= */
const keys = {
  left:'ArrowLeft', right:'ArrowRight',
  down:'ArrowDown', rotate:'ArrowUp', drop:'Space'
};
let waitKey=null;
const setKey = k => { waitKey=k; alert('키를 누르세요'); };
document.addEventListener('keydown',e=>{
  if(waitKey){ keys[waitKey]=e.code; waitKey=null; updateKeyUI(); return; }
  handleInput(e);
});
const updateKeyUI=()=>{
  leftKey.textContent=keys.left;
  rightKey.textContent=keys.right;
  downKey.textContent=keys.down;
  rotateKey.textContent=keys.rotate;
  dropKey.textContent=keys.drop;
};

/* ================= 테트리스 ================= */
const canvas=document.getElementById('tetris');
const ctx=canvas.getContext('2d');
ctx.scale(20,20);

const ROWS=20, COLS=12;
let arena, player, gameOver=false;
let dropInterval=700, dropCounter=0, lastTime=0;
let flashingRows=[];

const colors=[null,'#f00','#0ff','#0f0','#f0f','#ff0','#0ff','#00f','white'];

function resetGame(){
  arena=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  player={pos:{x:5,y:0}, matrix:null};
  gameOver=false;
  spawn();
}

function spawn(){
  const p='ILJOTSZ';
  player.matrix=createPiece(p[Math.random()*7|0]);
  player.pos={x:5,y:0};
  if(collide()) gameOver=true;
}

function createPiece(t){
  if(t==='I')return[[1],[1],[1],[1]];
  if(t==='O')return[[2,2],[2,2]];
  if(t==='T')return[[0,3,0],[3,3,3]];
  if(t==='L')return[[0,4],[0,4],[4,4]];
  if(t==='J')return[[5,0],[5,0],[5,5]];
  if(t==='S')return[[0,6,6],[6,6,0]];
  if(t==='Z')return[[7,7,0],[0,7,7]];
}

function collide(){
  return player.matrix.some((r,y)=>
    r.some((v,x)=>v && arena[y+player.pos.y]?.[x+player.pos.x]!==0)
  );
}

function merge(){
  player.matrix.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) arena[y+player.pos.y][x+player.pos.x]=v;
  }));
}

function clearLines(){
  flashingRows=[];
  arena.forEach((r,y)=>{ if(r.every(v=>v)) flashingRows.push(y); });
  if(!flashingRows.length) return;

  let flashes=0;
  const flash=setInterval(()=>{
    flashingRows.forEach(y=>{
      arena[y].fill(flashes%2?8:1);
    });
    flashes++;
    if(flashes===4){
      clearInterval(flash);
      flashingRows.forEach(y=>arena.splice(y,1));
      while(arena.length<ROWS) arena.unshift(Array(COLS).fill(0));
    }
  },100);
}

function rotate(){
  const m=player.matrix;
  player.matrix=m[0].map((_,i)=>m.map(r=>r[i]).reverse());
  if(collide()) player.matrix=m;
}

function drop(){
  player.pos.y++;
  if(collide()){
    player.pos.y--;
    merge();
    clearLines();
    spawn();
  }
}

function handleInput(e){
  if(!gameScreen.classList.contains('active')||gameOver) return;
  if(e.code===keys.left){ player.pos.x--; if(collide()) player.pos.x++; }
  if(e.code===keys.right){ player.pos.x++; if(collide()) player.pos.x--; }
  if(e.code===keys.down) drop();
  if(e.code===keys.rotate) rotate();
  if(e.code===keys.drop){
    while(!collide()) player.pos.y++;
    player.pos.y--; drop();
  }
}

function draw(){
  ctx.fillStyle='#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  arena.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){ ctx.fillStyle=colors[v]; ctx.fillRect(x,y,1,1); }
  }));
  if(player.matrix)
    player.matrix.forEach((r,y)=>r.forEach((v,x)=>{
      if(v){ ctx.fillStyle=colors[v]; ctx.fillRect(x+player.pos.x,y+player.pos.y,1,1); }
    }));
}

function update(time=0){
  const delta=time-lastTime;
  lastTime=time;
  if(!gameOver){
    dropCounter+=delta;
    if(dropCounter>dropInterval){ drop(); dropCounter=0; }
    draw();
  }
  requestAnimationFrame(update);
}

resetGame();
update();
</script>
</body>
</html>
